## Инструкции по запуску проектов:
Сначала нужно открыть папку EndToEndProject
Для нативного:
1. Открыть папку native
2. Открыть login.html в браузере

Для нативного с инфраструктурой:
1. Открыть git bash для папки with-infrastructure
2. Прописать npm run serve
npm run test: тесты  
npm run format: форматтер  
npm run build: сборка билда  
npm run lint и lint:fix : линтер  


Для проекта с фреймворком:
1. Открыть git bash для папки framework
2. Прописать npm run serve

## Ответы на вопросы
### Проект с нативными технологиями
HTML: использовался блочный подход к верстке вместе с flex-подходом. Все элементы формы расположены в блоках
для удобства читаемости (все блоки подписаны говорящими классами, идентификаторами). При у самого элемента формы
стоит свойство flex, чтобы дочерние элементы могли подстраиваться под разрешение экрана и выглядеть красиво.  
CSS: Media queries не использовались.  
JS:  
1. Для сохранения введенных данных использовался sessionStorage. Он относительно безопасен, так как очищается при закрытии вкладки.
2. Стрелочные функции показались довольно удобными тем, что можно сразу для события прописывать логику и удобны, когда нужно задать поведение при событии тем, что не нужно писать функцию, которая будет использована 1 раз. Но именованные функции все же привычнее и значительно улучшают читаемость кода.
 
### Проект с инфраструктурой
Я использовал менеджер пакетов npm, так как он уже встроен в Node.js. Он медленее аналогов, но хорош для небольших или учебных проектов.  

Для TypeScript я просмотрел параметры и нашел те, в которых говорилось про строгость проверок.
Так как в задании написано сделать проверки максимально строгими, я их включил.
А еще я поставил для module значение ESNext, потому что у меня все работало только с ним, а еще я использую vite, который, как я понимаю,
заточен под использование ES-модулей.  

Я использовал сборщик vite, так как он автоматически обновляет страницу при изменении файлов проекта, имеет встроенную поддержку TypeScript
и быстро запускает проекты за счет использования ES-модулей.  
  
В качестве линтера я поставил ESLint.  
"parser": "@typescript-eslint/parser" Установил парсер для проверки кода TypeScript.  
В расширения я установил те, что налаживают работу с TypeScript и форматтером prettier, чтобы форматтер и линтер не мешали друг другу в работе (при конфликте линтера и форматтера, ошибки форматтера игнорируются, например, с кавычками).
В правила я добавил запрет на any в TypeScript-коде, иначе зачем здесь TypeScript? Чтобы распознавать ошибки с типами еще до запуска проекта.
Проверку одинарных кавычек я поставил, чтобы не путаться с двойными.
А также поставил удаление неиспользуемых переменных, если что-то забуду убрать, и проверку точек с запятой в конце строки, потому что это бывает полезно (если бы это сразу не подчеркивалось в среде разработки).

В качестве форматтера я поставил prettier.  
Я поставил длину отступа 4, так как это привычнее всего, и в проекте мало кода, поэтому места для отображения более чем хватит.
Максимальную длину строки я поставил 100, чтобы не писать много кода в одну строку, но можно и больше, потому что код расположен не слишком близко к краю экрана.
Одинарные кавычки я поставил, так как такие настройки уже стоят в линтере.
Также я поставил автоматическое расположение ; в конец строки, чтобы не провоцировать ошибки (хотя это уже обрабатывается линтером).
Я запретил использование tab, потому что мне нравится, когда при нажатии backspace у меня иногда скачет курсор в строке.
  
Я поставил фреймворк тестирования jest, так как это, видимо, самый популярный фреймворк тестирования для JavaScript и TypeScript. 
Объянение конфигурации:   
preset: 'ts-jest/presets/default-esm'	Использует ts-jest для обработки TypeScript + по умолчанию ставит тестирование ES-модулей.  
testEnvironment	node (для бэкенда) или jsdom (для фронтенда).  
testMatch	Ищет файлы с тестами по шаблону *.test.ts.   
collectCoverage	Включение отчёта о покрытии кода тестами.  
moduleFileExtensions я добавил, так как без этого у меня не распознавались мои файлы как модули.  
В globals useESM я добавил по той же причине.  
Для testEnvironment я поставил jsdom, так как без этого в моих скриптах document имел значение undefined, а jsdom, как я понял, имитирует работу документа html.  


